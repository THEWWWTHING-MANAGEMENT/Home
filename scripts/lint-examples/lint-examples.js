#!/usr/bin/env node
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 */

const {execSync} = require('child_process');
const {promises: fs} = require('fs');
const path = require('path');

const glob = require('glob-promise');

/**
 * The root document to search for documents
 */
const documentsRoot = path.join(__dirname, '..', '..', 'docs');

/**
 * The directory to output generated files to
 */
const outputRoot = path.join(__dirname, 'out');

const args = process.argv.slice(2);

/**
 * Main function
 */
(async () => {
  try {
    const mappings = await extractExamples();
    process.exitCode = await lintExamples();
    await updateDocuments(mappings);
  } catch (ex) {
    console.error(ex);
    process.exit(1);
  }
})();

/**
 * Extracts all Snack player code examples inline in markdown into a unique
 * file per example. Returns a mapping from output files back to the original
 * markdown.
 */
async function extractExamples() {
  const documents = await glob('**/*.md', {
    cwd: documentsRoot,
    absolute: true,
  });
  const mappings = [];

  await fs.mkdir(outputRoot, {recursive: true});
  await fs.rm(outputRoot, {recursive: true});

  await Promise.all(
    documents.map(async doc => {
      mappings.push(...(await extractExamplesFromDocument(doc)));
    }),
  );

  return mappings;
}

/**
 * Extracts snack player examples from a given markdown file. Returns a mapping
 * from output files back to the original markdown.
 *
 * @param filename absolute filename of the documents root
 */
async function extractExamplesFromDocument(filename) {
  const fileContents = await fs.readFile(filename, {
    encoding: 'utf-8',
  });
  const snackRegex = /(```SnackPlayer(.*)\r?\n)((((?!```).)*\r?\n)+)```/g;
  const matches = [...fileContents.matchAll(snackRegex)];

  let matchIndex = 0;
  return await Promise.all(
    matches.map(async match => {
      const contentOffset = match.index + match[1].length;
      const snackURLParams = match[2].trim();
      const exampleName = new URLSearchParams(snackURLParams).get('name');
      const content = match[3];

      const baseFileName = path.relative(documentsRoot, filename);
      const outFile = path.join(
        outputRoot,
        `${baseFileName}-${++matchIndex}${
          exampleName ? '-' + exampleName : ''
        }.js`,
      );
      await fs.mkdir(path.dirname(outFile), {recursive: true});
      await fs.writeFile(outFile, content);

      return {
        documentPath: filename,
        examplePath: outFile,
        offset: contentOffset,
        length: content.length,
      };
    }),
  );
}

/**
 * Runs ESLint over the set of extracted documents, returning exit code
 */
async function lintExamples() {
  try {
    execSync(`npx eslint ${args.join(' ')} ${path.join(outputRoot, '**')}`, {
      cwd: __dirname,
      stdio: 'inherit',
    });

    return 0;
  } catch (ex) {
    return ex.status;
  }
}

/**
 * Updates in-document examples to match the newly linted example files
 *
 * @param mappings file mappings generated by extractExamples()
 */
async function updateDocuments(mappings) {
  const mappingsByDocument = {};
  for (const mapping of mappings) {
    if (mappingsByDocument[mapping.documentPath] === undefined) {
      mappingsByDocument[mapping.documentPath] = [];
    }
    mappingsByDocument[mapping.documentPath].push(mapping);
  }

  const documents = Object.keys(mappingsByDocument);
  await Promise.all(
    documents.map(async doc => {
      const documentMappings = mappingsByDocument[doc];
      documentMappings.sort((m1, m2) => m2.offset - m1.offset);

      const origDocumentContents = await fs.readFile(doc, {
        encoding: 'utf-8',
      });
      let newDocumentContents = origDocumentContents;
      for (const mapping of documentMappings) {
        const exampleContents = await fs.readFile(mapping.examplePath, {
          encoding: 'utf-8',
        });
        newDocumentContents =
          newDocumentContents.substring(0, mapping.offset) +
          exampleContents +
          newDocumentContents.substring(mapping.offset + mapping.length);
      }

      if (newDocumentContents !== origDocumentContents) {
        await fs.writeFile(doc, newDocumentContents);
      }
    }),
  );
}
